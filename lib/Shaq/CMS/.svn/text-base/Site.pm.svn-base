package CMS::Lite::Site;
use Moose;
use MooseX::AttributeHelpers;
use MooseX::Types::Path::Class;
use Template;
use Archive::Zip;
use DateTime;
use Path::Class qw/file/;
use File::ChangeNotify;
use CMS::Lite::Utils;
use CMS::Lite::Category;

has site_name => (
    is       => 'ro',
    isa      => 'Str',
    coerce   => 1,
    required => 1
);

has template_layout => (
    is       => 'ro',
    isa      => 'Str',
    coerce   => 1,
    required => 1
);
has doc_dir => (
    is       => 'ro',
    isa      => 'Path::Class::Dir',
    coerce   => 1,
    required => 1,
);
has root_dir => (
    is       => 'ro',
    isa      => 'Path::Class::Dir',
    coerce   => 1,
    required => 1,
);
has backup_dir => (
    is       => 'ro',
    isa      => 'Path::Class::Dir',
    coerce   => 1,
    required => 1,
);
has parser => (
    is         => 'ro',
    does       => 'CMS::Lite::ArchiveParser::Parser',
    required   => 1,
    lazy_build => 1
);

# category has some archives
has categories   => ( 
    is => 'rw', 
    isa => 'ArrayRef[CMS::Lite::Category]', 
    auto_deref => 1, 
    lazy_build=>1,
);

has menu_listset => (
    is         => 'rw',
    isa        => 'ArrayRef[HashRef]',
    metaclass  => 'Collection::Array',
    default    => sub { [] },
    auto_deref => 1,
    provides   => {
        push  => 'push_menulist',
    },
);

sub _build_categories {
    my ( $self ) = @_;

    my %cat_map;
    for my $dir ( $self->doc_dir->children  ) {
        next unless $dir->is_dir;
        
        my @list = $dir->dir_list;
        my $dirname = $list[-1];
        next unless $dirname =~ m/^(\d+)-(.*)$/;

        ### Categoryオブジェクトを生成
        my $category = CMS::Lite::Category->new( order=> $1, name => $2 );
        
        ### Categoryに格納する記事オブジェクトの生成を開始 
        my %archive_map;
        for my $file ( $dir->children ) {

            ### 指定してある形式のファイルのみを抽出
            next if $file->is_dir;        
            next unless $file->basename =~ m/^(\d+)-(.*)\.txt$/;


            my $order = $1;
            my $id    = $2;
            my $text  = $file->slurp;
  
            my $archive = $self->parser->parse( id => $id, text => $text );
             
            $archive_map{$order} = $archive;          

        }
        
        ### 記事を格納 
        for my $order ( sort keys %archive_map ) {
            my $archive = $archive_map{$order};
            $category->push_archive($archive);
        }

        my $order = $category->order;
        $cat_map{$order} = $category;
    }
    my @categories;
    for my $order ( sort keys %cat_map ) {
        my $category = $cat_map{$order};
        my $name  = $category->name;
        my @menu_list = $category->menu_list;
        push @categories, $category; 

        $self->push_menulist( { $name => [@menu_list] }  );
    };
    return [@categories];
}

__PACKAGE__->meta->make_immutable;

no Moose;

sub write { 
    my ( $self ) = @_;
    
    my $tt = Template->new( ABSOLUTE=>1 );

    my $site_name = $self->site_name;
    $site_name =~ s/_/ /g;
    $site_name =~ s/^\d+-//;

    for my $category ( $self->categories ) {
        
        for my $archive ( $category->archives ) {

            my $keywords_str = join ', ', $archive->keywords;

            my $vars = {
                site_name   => $site_name,
                title       => $archive->title || '',
                keywords    => $keywords_str || '',
                description => $archive->description || '',
                categories  => $self->categories || '',
                content     => $archive->content || '',
            };

            my $template    = $self->template_layout;
            
            my $target_file;
            if ( $archive->id eq 'index' ) {
                $target_file = "index.html"; 
            }
            else {
                $target_file = $category->order . "-" . $archive->id . ".html"; 
            }

            my $out_file    = file( $self->root_dir, $target_file )->stringify;
#            my $out_file    = CMS::Lite::Utils::path_to( $self->root_dir, $target_file )->stringify;

            $tt->process( $template, $vars, $out_file )
                or die $tt->error;
        }
    }
    return 1;
}

sub backup {
    my ( $self ) = @_;

    my $zip = Archive::Zip->new;
    my $dt  = DateTime->now( time_zone => 'local' );

    my $backup_file = "backup" . "_" . $dt->ymd('') . ".zip";

    $zip->addTree( $self->root_dir->stringify, 'backup' );
    $zip->writeToFileNamed( file( $self->backup_dir, $backup_file )->stringify );
}

1;




